#include "imgui_impl_sdlgpu.h"

#define SDL_GPU_CHECK(element,message) \
if(element == NULL) { \
ImGui_ImplSDLGpu_Data* dbg = ImGui_ImplSDLGpu_GetBackendData();\
dbg->SDLGpuInitInfo.DebugCallback(message);\
}\

const unsigned char shader_vert_spv[] = {
  0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x00, 0x08, 0x00,
  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00,
  0x1b, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00,
  0x02, 0x00, 0x00, 0x00, 0xc2, 0x01, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x05, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 0x06, 0x00, 0x04, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x55, 0x56, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x4f, 0x75, 0x74, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x61, 0x43, 0x6f, 0x6c,
  0x6f, 0x72, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00, 0x15, 0x00, 0x00, 0x00,
  0x61, 0x55, 0x56, 0x00, 0x05, 0x00, 0x06, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x67, 0x6c, 0x5f, 0x50, 0x65, 0x72, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78,
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x67, 0x6c, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74,
  0x69, 0x6f, 0x6e, 0x00, 0x05, 0x00, 0x03, 0x00, 0x1b, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x61, 0x50, 0x6f, 0x73, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x06, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x54, 0x72, 0x61,
  0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x00, 0x00, 0x06, 0x00, 0x07, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x63, 0x61, 0x6c,
  0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x20, 0x00, 0x00, 0x00, 0x73, 0x63, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x0f, 0x00, 0x00, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x15, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x48, 0x00, 0x05, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x03, 0x00,
  0x19, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x48, 0x00, 0x05, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x03, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x16, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x17, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00,
  0x0c, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x0e, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x03, 0x00,
  0x19, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x03, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x1f, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x11, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x17, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x18, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x21, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x4f, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x23, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x25, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x21, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,
  0x4f, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
  0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x81, 0x00, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
  0x51, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x05, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x50, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x2e, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00,
  0x2a, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x11, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x2f, 0x00, 0x00, 0x00,
  0x2e, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00
};
const unsigned int shader_vert_spv_len = 1344;
const unsigned char shader_frag_spv[] = {
  0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x00, 0x08, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00,
  0x02, 0x00, 0x00, 0x00, 0xc2, 0x01, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x00, 0x66, 0x43, 0x6f, 0x6c,
  0x6f, 0x72, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x55, 0x56, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x49, 0x6e, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x16, 0x00, 0x00, 0x00,
  0x73, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x00, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x16, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x16, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x17, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x17, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
  0x0e, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x19, 0x00, 0x09, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x03, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x15, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x15, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x36, 0x00, 0x05, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x10, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00,
  0x16, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0x57, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
  0x85, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x01, 0x00,
  0x38, 0x00, 0x01, 0x00
};
const unsigned int shader_frag_spv_len = 772;

struct ImGui_ImplSDLGpu_FrameRenderBuffers;
struct ImGui_ImplSDLGpu_WindowRenderBuffers;
bool ImGui_ImplSDLGpu_CreateDeviceObjects();
void ImGui_ImplSDLGpu_DestroyDeviceObjects();
void ImGui_ImplSDLGpu_DestroyFrameRenderBuffers(SDL_GpuDevice* device, ImGui_ImplSDLGpu_FrameRenderBuffers* buffers);
void ImGui_ImplSDLGpu_DestroyWindowRenderBuffers(SDL_GpuDevice* device, ImGui_ImplSDLGpu_WindowRenderBuffers* buffers);

struct ImGui_ImplSDLGpu_FrameRenderBuffers
{
	SDL_GpuBuffer* VertexBuffer;
	SDL_GpuBuffer* IndexBuffer;
	uint32_t VertexBufferSize;
	uint32_t IndexBufferSize;
	SDL_GpuBufferBinding VertexBufferBinding;
	SDL_GpuBufferBinding IndexBufferBinding;
};
struct ImGui_ImplSDLGpu_WindowRenderBuffers
{
	uint32_t            Index;
	uint32_t            Count;
	ImGui_ImplSDLGpu_FrameRenderBuffers* FrameRenderBuffers;
};
struct ImGui_ImplSDLGpu_Data
{
	ImGui_ImplSDLGpu_InitInfo                            SDLGpuInitInfo;
	SDL_GpuComputePipelineCreateInfo                     PipelineCreateFlags;
	SDL_GpuGraphicsPipelineResourceLayoutInfo            PipelineLayout;
	SDL_GpuGraphicsPipeline* Pipeline;
	SDL_GpuShader* VertexShader;
	SDL_GpuShader* FragmentShader;

	// Font data
	SDL_GpuSampler* FontSampler;
	SDL_GpuTexture* FontImage;

	// Render buffers for main window
	ImGui_ImplSDLGpu_WindowRenderBuffers MainWindowRenderBuffers;

	ImGui_ImplSDLGpu_Data()
	{
		memset((void*)this, 0, sizeof(*this));
	}
};

static ImGui_ImplSDLGpu_Data* ImGui_ImplSDLGpu_GetBackendData()
{
	return ImGui::GetCurrentContext() ? (ImGui_ImplSDLGpu_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;
}


bool ImGui_ImplSDLGpu_CreateDeviceObjects() {
	ImGui_ImplSDLGpu_Data* bd = ImGui_ImplSDLGpu_GetBackendData();
	ImGui_ImplSDLGpu_InitInfo* v = &bd->SDLGpuInitInfo;

	SDL_GpuSamplerStateCreateInfo samplerInfo = {};
	samplerInfo.magFilter = SDL_GPU_FILTER_LINEAR;
	samplerInfo.minFilter = SDL_GPU_FILTER_LINEAR;
	samplerInfo.addressModeU = SDL_GPU_SAMPLERADDRESSMODE_REPEAT;
	samplerInfo.addressModeV = SDL_GPU_SAMPLERADDRESSMODE_REPEAT;
	samplerInfo.addressModeW = SDL_GPU_SAMPLERADDRESSMODE_REPEAT;
	samplerInfo.minLod = -1000;
	samplerInfo.maxLod = 1000;
	samplerInfo.maxAnisotropy = 1.0f;
	SDL_GpuCreateSampler(bd->SDLGpuInitInfo.Device, &samplerInfo);
	SDL_GPU_CHECK(bd->FontSampler, "Failed to create font sampler \n")
	ImGui_ImplSDLGpu_CreatePipeline(v->Device, v->MSAASamples,bd->Pipeline);
}
void ImGui_ImplSDLGpu_DestroyDeviceObjects()
{
	ImGui_ImplSDLGpu_Data* bd = ImGui_ImplSDLGpu_GetBackendData();
	ImGui_ImplSDLGpu_InitInfo* v = &bd->SDLGpuInitInfo;
	ImGui_ImplSDLGpu_DestroyWindowRenderBuffers(v->Device, &bd->MainWindowRenderBuffers);
	ImGui_ImplSDLGpu_DestroyFontsTexture();

	if (bd->VertexShader) { SDL_GpuQueueDestroyShader(v->Device, bd->VertexShader); }
	if (bd->VertexShader) { SDL_GpuQueueDestroyShader(v->Device, bd->FragmentShader); }
	if (bd->FontSampler) { SDL_GpuQueueDestroySampler(v->Device, bd->FontSampler); }
	if (bd->Pipeline) { SDL_GpuQueueDestroyGraphicsPipeline(v->Device, bd->Pipeline); }
	bd->PipelineLayout = {};
	bd->PipelineCreateFlags = {};
}
void ImGui_ImplSDLGpu_DestroyFrameRenderBuffers(SDL_GpuDevice* device, ImGui_ImplSDLGpu_FrameRenderBuffers* buffers)
{
	if (buffers->VertexBuffer) { SDL_GpuQueueDestroyGpuBuffer(device, buffers->VertexBuffer); }
	if (buffers->IndexBuffer) { SDL_GpuQueueDestroyGpuBuffer(device, buffers->IndexBuffer); }
}
void ImGui_ImplSDLGpu_DestroyWindowRenderBuffers(SDL_GpuDevice* device, ImGui_ImplSDLGpu_WindowRenderBuffers* buffers)
{
	for (uint32_t n = 0; n < buffers->Count; n++)
	{
		ImGui_ImplSDLGpu_DestroyFrameRenderBuffers(device, &buffers->FrameRenderBuffers[n]);
	}
	IM_FREE(buffers->FrameRenderBuffers);
	buffers->FrameRenderBuffers = nullptr;
	buffers->Index = 0;
	buffers->Count = 0;
}

static void CreateOrResizeBuffer(SDL_GpuBuffer* buffer, uint32_t* bufferSize, uint32_t newSize, SDL_GpuBufferUsageFlags usageFlags) {
	ImGui_ImplSDLGpu_Data* bd = ImGui_ImplSDLGpu_GetBackendData();
	ImGui_ImplSDLGpu_InitInfo* v = &bd->SDLGpuInitInfo;

	if (buffer != NULL) {
		SDL_GpuQueueDestroyGpuBuffer(v->Device, buffer);
	}

	buffer = SDL_GpuCreateGpuBuffer(v->Device, usageFlags, newSize);
	*bufferSize = newSize;
}


static void ImGui_ImplSDLGpu_SetupRenderState(ImDrawData* draw_data,
	SDL_GpuGraphicsPipeline* pipeline,
	SDL_GpuRenderPass* renderPass,
	ImGui_ImplSDLGpu_FrameRenderBuffers* rb,
	int fb_width, int fb_height)
{
	ImGui_ImplSDLGpu_Data* bd = ImGui_ImplSDLGpu_GetBackendData();

	// Bind pipeline:
	SDL_GpuBindGraphicsPipeline(renderPass, pipeline);

	// Bind Vertex And Index Buffer:
	if (draw_data->TotalVtxCount > 0)
	{
		SDL_GpuBufferBinding vertex_buffers[1] = { rb->VertexBufferBinding };

		SDL_GpuBindVertexBuffers(renderPass, 0, 1, vertex_buffers);
		SDL_GpuBindIndexBuffer(renderPass, &rb->IndexBufferBinding, sizeof(ImDrawIdx) == 2 ? SDL_GPU_INDEXELEMENTSIZE_16BIT : SDL_GPU_INDEXELEMENTSIZE_32BIT);
	}

	// Setup viewport:
	SDL_GpuViewport viewport;
	viewport.x = 0;
	viewport.y = 0;
	viewport.w = fb_width;
	viewport.h = fb_height;
	viewport.minDepth = 0.0f;
	viewport.maxDepth = 1.0f;

	SDL_GpuSetViewport(renderPass, &viewport);

	// Setup scale and translation:
	// Our visible imgui space lies from draw_data->DisplayPps (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single viewport apps.
	float scale_translation[4];
	scale_translation[0] = 2.0f / draw_data->DisplaySize.x;
	scale_translation[1] = 2.0f / draw_data->DisplaySize.y;
	scale_translation[2] = -1.0f - draw_data->DisplayPos.x * scale_translation[0];
	scale_translation[3] = -1.0f - draw_data->DisplayPos.y * scale_translation[1];
	SDL_GpuPushVertexUniformData(renderPass, 0, scale_translation, sizeof(float) * 4);
}



IMGUI_IMPL_API bool ImGui_ImplSDLGpu_Init(ImGui_ImplSDLGpu_InitInfo* info)
{
	ImGuiIO& io = ImGui::GetIO();
	IMGUI_CHECKVERSION();
	IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");

	// Setup backend capabilities flags
	ImGui_ImplSDLGpu_Data* bd = IM_NEW(ImGui_ImplSDLGpu_Data)();
	io.BackendRendererUserData = (void*)bd;
	io.BackendRendererName = "imgui_impl_vulkan";
	io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.

	IM_ASSERT(info->Device != NULL);
	IM_ASSERT(info->Window != NULL);
	IM_ASSERT(info->RenderPass != NULL);


	bd->SDLGpuInitInfo = *info;

	ImGui_ImplSDLGpu_CreateDeviceObjects();

}

void ImGui_ImplSDLGpu_NewFrame()
{
	 ImGui_ImplSDLGpu_Data* bd = ImGui_ImplSDLGpu_GetBackendData();
	 if (!bd->FontImage) {
		 ImGui_ImplSDLGpu_CreateFontsTexture();
	 }
}

void ImGui_ImplSDLGpu_RenderDrawData(ImDrawData* draw_data, SDL_GpuRenderPass* renderPass, SDL_GpuGraphicsPipeline* pipeline)
{
	int fb_width = (int)(draw_data->DisplaySize.x * draw_data->FramebufferScale.x);
	int fb_height = (int)(draw_data->DisplaySize.y * draw_data->FramebufferScale.y);
	if (fb_width <= 0 || fb_height <= 0)
	{
		return;
	}

	ImGui_ImplSDLGpu_Data* bd = ImGui_ImplSDLGpu_GetBackendData();
	ImGui_ImplSDLGpu_InitInfo* v = &bd->SDLGpuInitInfo;
	if (pipeline == NULL) {
		pipeline = bd->Pipeline;
	}

	ImGui_ImplSDLGpu_WindowRenderBuffers* wrb = &bd->MainWindowRenderBuffers;
	if (wrb->FrameRenderBuffers == nullptr)
	{
		wrb->Index = 0;
		wrb->Count = v->ImageCount;
		wrb->FrameRenderBuffers = (ImGui_ImplSDLGpu_FrameRenderBuffers*)IM_ALLOC(sizeof(ImGui_ImplSDLGpu_FrameRenderBuffers) * wrb->Count);
		memset(wrb->FrameRenderBuffers, 0, sizeof(ImGui_ImplSDLGpu_FrameRenderBuffers) * wrb->Count);
	}

	IM_ASSERT(wrb->Count == v->ImageCount);
	wrb->Index = (wrb->Index + 1) % wrb->Count;
	ImGui_ImplSDLGpu_FrameRenderBuffers* rb = &wrb->FrameRenderBuffers[wrb->Index];
	if (draw_data->TotalVtxCount > 0)
	{
		uint32_t vertexBufferSize = draw_data->TotalVtxCount * sizeof(ImDrawVert);
		uint32_t indexBufferSize = draw_data->TotalIdxCount * sizeof(ImDrawIdx);

		// Create or resize the vertex/index buffers
		if (rb->VertexBuffer == NULL || rb->VertexBufferSize < vertexBufferSize) {
			CreateOrResizeBuffer(rb->VertexBuffer, &rb->VertexBufferSize, vertexBufferSize, SDL_GPU_BUFFERUSAGE_VERTEX_BIT);
		}
		if (rb->IndexBuffer == NULL || rb->IndexBufferSize < indexBufferSize) {
			CreateOrResizeBuffer(rb->IndexBuffer, &rb->IndexBufferSize, indexBufferSize, SDL_GPU_BUFFERUSAGE_INDEX_BIT);
		}


		// Upload vertex/index data into a single contiguous GPU buffer
		ImDrawVert* vtx_dst = nullptr;
		ImDrawIdx* idx_dst = nullptr;

		SDL_GpuCommandBuffer* copyCommandBuffer = SDL_GpuAcquireCommandBuffer(v->Device);

		SDL_GpuCopyPass* vertexCopyPass = SDL_GpuBeginCopyPass(copyCommandBuffer);
		SDL_GpuBufferCopy vertexBufferCopy;
		vertexBufferCopy.size = vertexBufferSize;
		vertexBufferCopy.srcOffset = 0;
		vertexBufferCopy.dstOffset = 0;


		SDL_GpuTransferBuffer* vertexTransferBuffer = SDL_GpuCreateTransferBuffer(v->Device,
			SDL_GPU_TRANSFERUSAGE_BUFFER,
			SDL_GPU_TRANSFER_MAP_WRITE,
			vertexBufferSize);

		SDL_GpuMapTransferBuffer(v->Device, vertexTransferBuffer, SDL_FALSE, (void**)&vtx_dst);
		for (int n = 0; n < draw_data->CmdListsCount; n++)
		{
			const ImDrawList* cmd_list = draw_data->CmdLists[n];
			memcpy(vtx_dst, cmd_list->VtxBuffer.Data, cmd_list->VtxBuffer.Size * sizeof(ImDrawVert));
			vtx_dst += cmd_list->VtxBuffer.Size;
		}
		SDL_GpuUnmapTransferBuffer(v->Device, vertexTransferBuffer);
		SDL_GpuUploadToBuffer(vertexCopyPass, vertexTransferBuffer, rb->VertexBuffer, &vertexBufferCopy, SDL_FALSE);
		SDL_GpuEndCopyPass(vertexCopyPass);


		SDL_GpuCopyPass* indexCopyPass = SDL_GpuBeginCopyPass(copyCommandBuffer);

		SDL_GpuBufferCopy indexBufferCopy;
		vertexBufferCopy.size = indexBufferSize;
		vertexBufferCopy.srcOffset = 0;
		vertexBufferCopy.dstOffset = 0;

		SDL_GpuTransferBuffer* indexTransferBuffer = SDL_GpuCreateTransferBuffer(v->Device,
			SDL_GPU_TRANSFERUSAGE_BUFFER,
			SDL_GPU_TRANSFER_MAP_WRITE,
			indexBufferSize);

		SDL_GpuMapTransferBuffer(v->Device, indexTransferBuffer, SDL_FALSE, (void**)&idx_dst);
		for (int n = 0; n < draw_data->CmdListsCount; n++)
		{
			const ImDrawList* cmd_list = draw_data->CmdLists[n];
			memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawVert));
			idx_dst += cmd_list->IdxBuffer.Size;
		}
		SDL_GpuUnmapTransferBuffer(v->Device, indexTransferBuffer);
		SDL_GpuUnmapTransferBuffer(v->Device, indexTransferBuffer);
		SDL_GpuUploadToBuffer(indexCopyPass, indexTransferBuffer, rb->IndexBuffer, &indexBufferCopy, SDL_FALSE);
		SDL_GpuEndCopyPass(indexCopyPass);

		SDL_GpuSubmit(copyCommandBuffer);
	}
		// Setup desired SDL_Gpu state
		ImGui_ImplSDLGpu_SetupRenderState(draw_data, pipeline, renderPass, rb, fb_width, fb_height);

		// Will project scissor/clipping rectangles into framebuffer space
		ImVec2 clip_off = draw_data->DisplayPos;         // (0,0) unless using multi-viewports
		ImVec2 clip_scale = draw_data->FramebufferScale; // (1,1) unless using retina display which are often (2,2)

		int global_vtx_offset = 0;
		int global_idx_offset = 0;
		for (int n = 0; n < draw_data->CmdListsCount; n++)
		{
			const ImDrawList* cmd_list = draw_data->CmdLists[n];
			for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
			{
				const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
				if (pcmd->UserCallback != nullptr)
				{
					// User callback, registered via ImDrawList::AddCallback()
					// (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
					if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
						ImGui_ImplSDLGpu_SetupRenderState(draw_data, pipeline, renderPass, rb, fb_width, fb_height);
					else
						pcmd->UserCallback(cmd_list, pcmd);
				}
				else
				{
					// Project scissor/clipping rectangles into framebuffer space
					ImVec2 clip_min((pcmd->ClipRect.x - clip_off.x) * clip_scale.x, (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
					ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);

					ImVec2 clip_min((pcmd->ClipRect.x - clip_off.x) * clip_scale.x, (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
					ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
					if (clip_min.x < 0.0f) { clip_min.x = 0.0f; }
					if (clip_min.y < 0.0f) { clip_min.y = 0.0f; }
					if (clip_max.x > fb_width) { clip_max.x = (float)fb_width; }
					if (clip_max.y > fb_height) { clip_max.y = (float)fb_height; }
					if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
					{
						continue;
					}


					SDL_GpuRect scissor;
					scissor.x = (int32_t)clip_min.x;
					scissor.y = (int32_t)clip_min.y;
					scissor.w = (uint32_t)(clip_max.x - clip_min.x);
					scissor.h = (uint32_t)(clip_max.y - clip_min.y);

					SDL_GpuSetScissor(renderPass, &scissor);

					SDL_GpuTextureSamplerBinding binding;
					binding.sampler = bd->FontSampler;
					binding.texture = (SDL_GpuTexture*)pcmd->TextureId;
					SDL_GpuTextureSamplerBinding samplerBinding[1] = { binding };
					SDL_GpuBindFragmentSamplers(renderPass, 0, &binding, 1);
					SDL_GpuDrawInstancedPrimitives(renderPass, pcmd->VtxOffset + global_vtx_offset,
						pcmd->IdxOffset + global_idx_offset, pcmd->ElemCount, 1);
				}
			}
			global_idx_offset += cmd_list->IdxBuffer.Size;
			global_vtx_offset += cmd_list->VtxBuffer.Size;
		}

		SDL_GpuRect scissor = { 0, 0 ,  (uint32_t)fb_width, (uint32_t)fb_height };
		SDL_GpuSetScissor(renderPass, &scissor);
}

bool ImGui_ImplSDLGpu_CreateFontsTexture() {
	ImGuiIO& io = ImGui::GetIO();
	ImGui_ImplSDLGpu_Data* bd = ImGui_ImplSDLGpu_GetBackendData();
	ImGui_ImplSDLGpu_InitInfo* v = &bd->SDLGpuInitInfo;

	unsigned char* pixels;
	int width, height;
	io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

	SDL_GpuTextureCreateInfo textureInfo;
	textureInfo.format = SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UINT;
	textureInfo.width = width;
	textureInfo.height = height;
	textureInfo.depth = 1;
	textureInfo.isCube = SDL_FALSE;
	textureInfo.layerCount = 1;
	textureInfo.levelCount = 1;
	textureInfo.usageFlags = SDL_GPU_TEXTUREUSAGE_SAMPLER_BIT;
	bd->FontImage = SDL_GpuCreateTexture(v->Device, &textureInfo);

	SDL_GpuCommandBuffer* cmd = SDL_GpuAcquireCommandBuffer(v->Device);
	SDL_GpuCopyPass* textureCopyPass = SDL_GpuBeginCopyPass(cmd);

	SDL_GpuBufferImageCopy imageCopy;
	imageCopy.bufferImageHeight = height;
	imageCopy.bufferStride = width * 4;
	imageCopy.bufferOffset = 0;

	SDL_GpuTextureRegion textureRegion;
	textureRegion.w = width;
	textureRegion.h = height;
	textureRegion.d = 1;
	textureRegion.x = 0;
	textureRegion.y = 0;
	textureRegion.z = 0;
	textureRegion.textureSlice.layer = 0;
	textureRegion.textureSlice.mipLevel = 0;
	textureRegion.textureSlice.texture = bd->FontImage;
	char* map = nullptr;
	SDL_GpuTransferBuffer* textureTransferBuffer = SDL_GpuCreateTransferBuffer(v->Device,
		SDL_GPU_TRANSFERUSAGE_TEXTURE,
		SDL_GPU_TRANSFER_MAP_WRITE,
		sizeof(uint8_t) * width *height* 4);

	SDL_GpuMapTransferBuffer(v->Device, textureTransferBuffer, SDL_FALSE, (void**)(&map));
	memcpy(map, pixels, sizeof(uint8_t) * width * height * 4);
	SDL_GpuUnmapTransferBuffer(v->Device, textureTransferBuffer);
	SDL_GpuUploadToTexture(textureCopyPass,textureTransferBuffer, &textureRegion,&imageCopy,SDL_FALSE);
	SDL_GpuEndCopyPass(textureCopyPass);
	SDL_GpuSubmit(cmd);

	io.Fonts->SetTexID((void*)bd->FontImage);
}

static void ImGui_ImplSDLGpu_CreateShaderModules(SDL_GpuDevice* device)
{
	ImGui_ImplSDLGpu_Data* bd = ImGui_ImplSDLGpu_GetBackendData();
	if (bd->VertexShader == NULL) {
		SDL_GpuShaderCreateInfo vertexShaderInfo;
		vertexShaderInfo.code = shader_vert_spv;
		vertexShaderInfo.codeSize = sizeof(shader_vert_spv);
		vertexShaderInfo.entryPointName = "main";
		vertexShaderInfo.format = SDL_GPU_SHADERFORMAT_SPIRV;
		vertexShaderInfo.stage = SDL_GPU_SHADERSTAGE_VERTEX;
		bd->VertexShader = SDL_GpuCreateShader(device, &vertexShaderInfo);
	}
	if (bd->FragmentShader == NULL) {
		SDL_GpuShaderCreateInfo fragmentShaderInfo;
		fragmentShaderInfo.code = shader_frag_spv;
		fragmentShaderInfo.codeSize = sizeof(shader_frag_spv);
		fragmentShaderInfo.entryPointName = "main";
		fragmentShaderInfo.format = SDL_GPU_SHADERFORMAT_SPIRV;
		fragmentShaderInfo.stage = SDL_GPU_SHADERSTAGE_FRAGMENT;
		bd->FragmentShader = SDL_GpuCreateShader(device, &fragmentShaderInfo);
	}

}

static void ImGui_ImplSDLGpu_CreatePipeline(SDL_GpuDevice* device, SDL_GpuSampleCount MSAASamples, SDL_GpuGraphicsPipeline* pipeline) {
	ImGui_ImplSDLGpu_Data* bd = ImGui_ImplSDLGpu_GetBackendData();
	ImGui_ImplSDLGpu_CreateShaderModules(device);
	bd->PipelineLayout.samplerCount = 1;
	bd->PipelineLayout.uniformBufferCount = 1;
	bd->PipelineLayout.storageBufferCount = 0;
	bd->PipelineLayout.storageTextureCount = 0;
	
	SDL_GpuVertexBinding vertexBinding[1];
	vertexBinding[0].binding = 0;
	vertexBinding[0].inputRate = SDL_GPU_VERTEXINPUTRATE_VERTEX;
	vertexBinding[0].stride = sizeof(ImDrawVert);
	vertexBinding[0].stepRate = 1;

	SDL_GpuVertexAttribute vertexAttributes[3];
	vertexAttributes[0].binding = 0;
	vertexAttributes[0].location = 0;
	vertexAttributes[0].format = SDL_GPU_VERTEXELEMENTFORMAT_VECTOR2;
	vertexAttributes[0].offset = offsetof(ImDrawVert, pos);

	vertexAttributes[1].binding = 0;
	vertexAttributes[1].location = 1;
	vertexAttributes[1].format = SDL_GPU_VERTEXELEMENTFORMAT_VECTOR2;
	vertexAttributes[1].offset = offsetof(ImDrawVert, uv);

	vertexAttributes[2].binding = 0;
	vertexAttributes[2].location = 2;
	vertexAttributes[2].format = SDL_GPU_VERTEXELEMENTFORMAT_BYTE4;
	vertexAttributes[2].offset = offsetof(ImDrawVert, col);

	SDL_GpuVertexInputState vertexInputState;
	vertexInputState.vertexAttributeCount = 3;
	vertexInputState.vertexAttributes = vertexAttributes;
	vertexInputState.vertexBindingCount = 1;
	vertexInputState.vertexBindings = vertexBinding;

	SDL_GpuRasterizerState  rasterizerState = {};
	rasterizerState.cullMode = SDL_GPU_CULLMODE_NONE;
	rasterizerState.frontFace = SDL_GPU_FRONTFACE_COUNTER_CLOCKWISE;
	rasterizerState.depthBiasEnable = SDL_FALSE;

	SDL_GpuMultisampleState multisampleState = {};
	multisampleState.multisampleCount = (MSAASamples != 0) ? MSAASamples : SDL_GPU_SAMPLECOUNT_1;
	multisampleState.sampleMask = UINT32_MAX;

	SDL_GpuColorAttachmentBlendState blendState = {};
	blendState.blendEnable = SDL_TRUE;
	blendState.srcColorBlendFactor = SDL_GPU_BLENDFACTOR_SRC_ALPHA;
	blendState.dstColorBlendFactor = SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA;
	blendState.colorBlendOp = SDL_GPU_BLENDOP_ADD;
	blendState.srcAlphaBlendFactor = SDL_GPU_BLENDFACTOR_ONE;
	blendState.dstAlphaBlendFactor = SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA;
	blendState.alphaBlendOp = SDL_GPU_BLENDOP_ADD;
	blendState.colorWriteMask = SDL_GPU_COLORCOMPONENT_R_BIT | SDL_GPU_COLORCOMPONENT_G_BIT |
		SDL_GPU_COLORCOMPONENT_B_BIT | SDL_GPU_COLORCOMPONENT_A_BIT;

	SDL_GpuColorAttachmentDescription attachmentDesc[1];
	attachmentDesc[0].format = SDL_GpuGetSwapchainFormat(device, bd->SDLGpuInitInfo.Window);
	attachmentDesc[0].blendState = blendState;


	SDL_GpuGraphicsPipelineAttachmentInfo attachmentInfo = {};
	attachmentInfo.colorAttachmentCount = 1;
	attachmentInfo.colorAttachmentDescriptions = attachmentDesc;
	attachmentInfo.hasDepthStencilAttachment = SDL_FALSE;

	SDL_GpuGraphicsPipelineCreateInfo pipelineInfo = {};
	pipelineInfo.vertexShader = bd->VertexShader;
	pipelineInfo.fragmentShader = bd->FragmentShader;
	pipelineInfo.vertexInputState = vertexInputState;
	pipelineInfo.primitiveType = SDL_GPU_PRIMITIVETYPE_TRIANGLELIST;
	pipelineInfo.rasterizerState = rasterizerState;
	pipelineInfo.multisampleState = multisampleState;
	pipelineInfo.depthStencilState = {};
	pipelineInfo.attachmentInfo = attachmentInfo;
	pipelineInfo.vertexResourceLayoutInfo = {};
	pipelineInfo.fragmentResourceLayoutInfo = {};
	pipelineInfo.blendConstants[0] = 0;
	pipelineInfo.blendConstants[1] = 0;
	pipelineInfo.blendConstants[2] = 0;
	pipelineInfo.blendConstants[3] = 0;

	pipeline = SDL_GpuCreateGraphicsPipeline(device, &pipelineInfo);
}
